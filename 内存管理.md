# 内存管理

### CADisplayLink、NSTimer使用注意点:</br>
1.CADisplayLink、NSTimer会对target产生强引用,如果target又对他们产生强引用,就会产生循环引用</br>
2.这两个定时器存在不准时的可能性


解决方案1:消息转发机制+中间对象进行处理
```objc
//MXTestProxy:NSObject
+ (instancetype)proxyWithTarget:(id)target {
    MXTestProxy *pro = [[MXTestProxy alloc]init];
    pro.target = target;
    return pro;
    
}

- (id)forwardingTargetForSelector:(SEL)aSelector {
    return self.target;
}


//CADisplayLink
self.link = [CADisplayLink displayLinkWithTarget:[MXTestProxy proxyWithTarget:self] selector:@selector(test)];
[self.link addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];

//注:CADisplayLink无需设置时间,因为其保证调用频率和屏幕的刷帧频率一致,60FTP(1秒调用60次).
```

由此,可以使用系统内部的NSProxy类,NSProxy本来就是用于设计消息转发的

```objc
//MXProxy : NSProxy
+ (instancetype)proxyWithTarget:(id)target {
 
    //NSProxy对象不需要调用init,因为它根本没有init方法,只需要调用alloc即可
    MXProxy *proxy = [MXProxy alloc];
    proxy.target = target;
    return proxy;
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel {
    return [self.target methodSignatureForSelector:sel];
}

- (void)forwardInvocation:(NSInvocation *)invocation {
    [invocation invokeWithTarget:self.target];
}

//CADisplayLink
self.link = [CADisplayLink displayLinkWithTarget:[MXProxy proxyWithTarget:self] selector:@selector(test)];
[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];
```

* 继承自NSObject,方法调用流程:即原先消息机制的3个部分
* 继承自NSProxy,直接就进入消息转发,但其并没有`- (id)forwardingTargetForSelector:(SEL)aSelector`方法

>若是继承自NSProxy的对象调用对应的NSObject的方法,由于其内部就是消息转发,故会令消息转发者发送对应消息,即假设proxy是继承自NSProxy,则[proxy isKindOfClass]方法的实际调用者还是消息转发者,而不是proxy

