# 多线程

### 多线程相关知识:</br>
**同步线程**:dispatch中的sync函数,即是在当前线程做事情

**异步函数**:dispatch中的async函数,即在另外一条线程做事情

**并发队列**:允许多个任务同时执行
可以让多个任务并发(同时)执行(自动开启多个线程同时执行任务)</br>
并发功能只有在异步函数(dispatch_async)下才有效

**串行队列**:让任务一个接一个地执行(执行完一个再执行下一个)

>注:通过CF开头的函数创建出来的变量,需要手动调用CFRealease去释放,但GCD的是不用的

**同步**与**异步**:能否开启新线程 (决定了是在哪个线程执行)</br>
* **同步**:在当前线程中执行任务.不具备开启新线程的能力
* **异步**:在新的线程中执行任务,具备开启新线程的能力
* **同步函数**:立马在当前线程执行任务,执行完毕后才能继续往下执行,即同步函数内的任务不执行完,该函数就会卡住,不会继续往下执行
* **异步函数**:不要求立马在当前线程执行任务,会等上一个任务执行完再执行

**并发和串行**:任务的执行方式</br>
* **并发**:多个任务并发(同时)执行
* **串行**:一个任务执行完成后,再执行下一个任务

**主队列**是一种特殊的串行队列</br>
只要是放到主队列的任务,都是在主线程执行

![](Snip20180611_5.png)

### 死锁:</br>
队列的特点:FIFO(First In First Out)先进先出

产生死锁的两个情况:</br>
* 当同步函数内的队列是主队列时,会产生死锁
* 使用sync函数往当前串行队列中添加任务,就会产生死锁

### 队列组:</br>

```objc

    dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_group_async(group, queue, ^{
        for (int i = 0; i<5; i++) {
            NSLog(@"任务1 ----%@",[NSThread currentThread]);
        };
    });
    
    dispatch_group_async(group, queue, ^{
        for (int i = 0; i<5; i++) {
            NSLog(@"任务2 ----%@",[NSThread currentThread]);
        };
    });
    
    //等前面的任务都执行完,会自动执行这个任务
    dispatch_group_notify(group, queue, ^{
        
        dispatch_async(dispatch_get_main_queue(), ^{
            for (int i = 0; i<5; i++) {
                NSLog(@"任务3 ----%@",[NSThread currentThread]);
            };
        });
    });

```

### 多线程的安全隐患:</br>
Q:一块资源可能会被多个线程共享,容易造成数据错乱和数据异常的问题</br>
A:解决方法:使用线程同步技术(同步:协同步调,按预定的先后顺序次序进行)</br>
　常用的线程同步技术:**加锁**
 
* **OSSpinLock**(自旋锁):等待锁的线程会处于忙等状态,一直占用着CPU资源(high-level lock)

```objc
//需要导入头文件<libkern/OSAtomic.h>

_lock = OS_SPINLOCK_INIT;//初始化
/*
//也可以这么初始化锁
static OSSpinLock lock;

static dispatch_once_t onceToken;
dispatch_once(&onceToken, ^{
    lock = 0;//OS_SPINLOCK_INIT的值就是0
});

*/
    
OSSpinLockLock(&_lock);//加锁
//需加锁代码
OSSpinLockUnlock(&_lock);//解锁
```

注意点:</br>
* 所有线程应该共用一把锁,不然还是会存在问题,每次都创建一把新锁</br> 
若有好几个方法同一时间只能使用一个方法,需要共用一把锁
* 原理:类似写了一个while循环
* 目前已经不再安全,有可能出现优先级反转的问题</br>
若有线程1和线程2,假设线程1的优先级大于线程2,线程2先进入代码,发现锁未加锁,故加锁执行代码,线程1后进入,发现该锁已经被加锁,故忙等,但由于线程1优先级大于线程2,CPU分配更多时间执行线程1的代码,可能导致线程2的代码没有时间执行,导致无法解锁会进入一个类似死锁的状态,目前苹果已经不推荐使用 
 
也可以使用static静态初始化锁,使自旋锁唯一,故锁不一定需要使用属性的方式</br> 
无法在static变量初始化时动态调用函数,只能取个值,因为static是静态初始化,右边的值在编译就需要确定,若需要动态调用函数,需要再次使用once函数,在once代码里赋值

当多条线程需要同时修改同一个值时,基本需要加锁,读取则不需要

* **os_unfair_lock**(low-level lock)

底层调用看,为互斥锁,等待os_unfair_lock锁的线程会处于休眠,而并非忙等,等不到锁就休眠(ios10以上使用)

```objc
//需要导入头文件<os/lock.h>

_lock = OS_UNFAIR_LOCK_INIT;//初始化

os_unfair_lock_lock(&_lock);//加锁
//需加锁代码
os_unfair_lock_unlock(&_lock);//解锁
```

* **pthread_mutex**(low-level lock)

互斥锁,等待锁的线程会处于休眠状态,不需要使用时,要手动销毁

>注意点:结构体静态初始化只允许定义的同时进行赋值,不允许后续使用set方法赋值

```objc
struct Date {
  int year;
  int month;
}

struct Date date = {2011,10}//这样是可以的

struct Date date;
date = {2011,10}//这样是不可以的

//就是因为这样,解释了为什么不能定义一个pthread_mutex,再通过self的点语法方式对其进行静态初始化的原因
```

```objc

//需要导入头文件<pthread.h>

//静态初始化
//self.lock = PTHREAD_MUTEX_INITIALIZER;
    
pthread_mutexattr_t attr;
pthread_mutexattr_init(&attr);
pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_DEFAULT);
    
pthread_mutex_init(&_lock, &attr);
 
//锁和条件可以在对象销毁时销毁(declloc)
//属性可以立马销毁
pthread_mutexattr_destroy(&attr);


/*
pthread_mutex_init(mutex, NULL);
//初始化时,可以将&attr传NULL,即默认为PTHREAD_MUTEX_DEFAULT

*/
```

将`PTHREAD_MUTEX_DEFAULT`属性替换为`PTHREAD_MUTEX_RECUESIVE`,将锁变为递归锁,解决递归可能导致死锁的问题</br>
>递归锁的本质:允许同一个线程对一把锁进行重复加锁

```objc
//条件锁

- (void)define{
  pthread_mutexattr_t attr;
  pthread_mutexattr_init(&attr);
  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_DEFAULT);
    
  pthread_cond_init(&_con, NULL);//创建一个条件
    
  pthread_mutex_init(&_lock, &attr);
    
  pthread_mutexattr_destroy(&attr);

}

- (void)using1{
  pthread_mutex_lock(&_lock);
    
  //需要执行的代码
  pthread_cond_wait(&_con, &_lock);//会休眠,将锁放开,等待信号量到来,再次加锁执行下面代码
    
  pthread_mutex_unlock(&_lock);
}

- (void)using2{
  pthread_cond_signal(&_con);//告知对应的条件锁,该锁已经放开,可以继续使用
}
```

通过创建条件锁后,pthread_mutex能够办到线程等待的效果(多线程的依赖问题)

>tip:</br>
>* 在汇编中敲入si,就是汇编指令级别的一行,遇到函数调用会进入函数内部
>* 汇编中敲入c,就是直接到断点的位置