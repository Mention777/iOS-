# 多线程

### 多线程相关知识:</br>
**同步线程**:dispatch中的sync函数,即是在当前线程做事情

**异步函数**:dispatch中的async函数,即在另外一条线程做事情

**并发队列**:允许多个任务同时执行
可以让多个任务并发(同时)执行(自动开启多个线程同时执行任务)</br>
并发功能只有在异步函数(dispatch_async)下才有效

**串行队列**:让任务一个接一个地执行(执行完一个再执行下一个)

>注:通过CF开头的函数创建出来的变量,需要手动调用CFRealease去释放,但GCD的是不用的

**同步**与**异步**:能否开启新线程 (决定了是在哪个线程执行)</br>
* **同步**:在当前线程中执行任务.不具备开启新线程的能力
* **异步**:在新的线程中执行任务,具备开启新线程的能力
* **同步函数**:立马在当前线程执行任务,执行完毕后才能继续往下执行,即同步函数内的任务不执行完,该函数就会卡住,不会继续往下执行
* **异步函数**:不要求立马在当前线程执行任务,会等上一个任务执行完再执行

**并发和串行**:任务的执行方式</br>
* **并发**:多个任务并发(同时)执行
* **串行**:一个任务执行完成后,再执行下一个任务

**主队列**是一种特殊的串行队列</br>
只要是放到主队列的任务,都是在主线程执行

![](Snip20180611_5.png)

### 死锁:</br>
队列的特点:FIFO(First In First Out)先进先出

产生死锁的两个情况:</br>
* 当同步函数内的队列是主队列时,会产生死锁
* 使用sync函数往当前串行队列中添加任务,就会产生死锁

### 队列组:</br>

```objc

    dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_group_async(group, queue, ^{
        for (int i = 0; i<5; i++) {
            NSLog(@"任务1 ----%@",[NSThread currentThread]);
        };
    });
    
    dispatch_group_async(group, queue, ^{
        for (int i = 0; i<5; i++) {
            NSLog(@"任务2 ----%@",[NSThread currentThread]);
        };
    });
    
    //等前面的任务都执行完,会自动执行这个任务
    dispatch_group_notify(group, queue, ^{
        
        dispatch_async(dispatch_get_main_queue(), ^{
            for (int i = 0; i<5; i++) {
                NSLog(@"任务3 ----%@",[NSThread currentThread]);
            };
        });
    });

```

### 多线程的安全隐患:</br>
Q:一块资源可能会被多个线程共享,容易造成数据错乱和数据异常的问题</br>
A:解决方法:使用线程同步技术(同步:协同步调,按预定的先后顺序次序进行)</br>
　常用的线程同步技术:**加锁**
 
* **OSSpinLock**(自旋锁):等待锁的线程会处于忙等状态,一直占用着CPU资源

```objc
//需要导入头文件<libkern/OSAtomic.h>

_lock = OS_SPINLOCK_INIT;//初始化
/*
//也可以这么初始化锁
static OSSpinLock lock;

static dispatch_once_t onceToken;
dispatch_once(&onceToken, ^{
    lock = 0;//OS_SPINLOCK_INIT的值就是0
});

*/
    
OSSpinLockLock(&_lock);//加锁
//需加锁代码
OSSpinLockUnlock(&_lock);//解锁
```

注意点:</br>
* 所有线程应该共用一把锁,不然还是会存在问题,每次都创建一把新锁</br> 
若有好几个方法同一时间只能使用一个方法,需要共用一把锁
* 原理:类似写了一个while循环
* 目前已经不再安全,有可能出现优先级反转的问题,即如果等待锁的线程优先级高,它会一直占用着CPU资源,优先级低的线程就无法释放锁,目前苹果已经不推荐使用 
 
也可以使用static静态初始化锁,使自旋锁唯一,故锁不一定需要属性</br> 
无法在static变量初始化时动态调用函数,只能取个值,因为static是静态初始化,右边的值在编译就需要确定,若需要动态调用函数,需要再次使用once函数

当多条线程需要同时修改同一个值时,基本需要加锁,读取则不需要

